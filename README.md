# React18 SSR demo 案例

服务端生成页面，客户端处理事件（水合）,服务端和客户端进行同构，即 ssr。

HTML 结构已由服务端生成好了，客户端只需做水合处理。

ReactDOM.render() 有俩个作用: 生成 HTML 结构; 一个是绑定事件实现动态 功能。

## 客户端路由

- 客户端请求服务器；
- 服务端返回 HTML 给浏览器，浏览器渲染显示页面；
- 浏览器发现需要外链 JS 资源，加载 JS 资源；
- 加载好的 JS 资源在浏览器端执行；
- js 中的 React 代码开始实现路由功能；
- 路由代码首先获取地址栏中的地址，然后根据不同的地址同路由匹配渲染相应内容。

- [x] 实现了 数据拉功能

但存在一部分问题: 数据是客户端直接拉取 api 接口，没有服务端渲染，实际需要通过 ssr 服务器进行代理。

解决办法：

每次组件定义一个 loadData 方法，在服务端渲染时，通过 loadData 方法获取数据，然后渲染到页面中。

React 18 之后的服务端渲染，Streaming SSR with selective hydration（选择性水合），像流水一样，打造一个从服务端到客户端持续不断的渲染管线，而不是 renderToString 那样一次性的渲染机制。

在 React18 之前，这个操作必须是整体性的，而水合的过程可能比较慢，会引起局部卡顿，所以选择性水合就应运而生了。

服务端渲染把简单的 res.send 改为了 res.socket 这样的渲染就从单次行为变为了持续性的行为。打破了从前单行的限制，优化前端的加载速度和可交互所需等待时间。

服务端的流式 HTML 使用 `<Suspense></Suspense>`。在 React18 之前，React.lazy 不支持服务端渲染，而在 React18 版本，被 `<Suspense>` 所包裹的子组件可以延后水合。

> 服务器负责请求数据，客户端负责渲染页面。
>
> 服务器开启了一个 proxy 代理，客户端请求时，服务器代理请求，返回数据给客户端。

- [x] 实现客户端仅在初始渲染时, 执行 `getClientStore()`，后续路由切换时，不再执行 `getClientStore()`，而是直接使用上一次的 store。
